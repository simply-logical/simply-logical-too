
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>8.3. Abduction and diagnostic reasoning &#8212; Simply Logical:&lt;br&gt;Intelligent Reasoning by Example</title>
    
  <link href="../../../_static/css/theme.css" rel="stylesheet">
  <link href="../../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-prolog.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/lpn.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jquery-ui.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sl.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/lpn.js"></script>
    <script src="../../../_static/jquery-ui.min.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="8.4. The complete picture" href="8.4.html" />
    <link rel="prev" title="8.2. The semantics of incomplete information" href="8.2.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-112595762-2', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../_static/SL.svg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Simply Logical:<br>Intelligent Reasoning by Example</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../simply-logical.html">
   Simply Logical
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../0_preface/_preface.html">
   Preface to the online edition
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../0_preface/glossary.html">
     Glossary
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../1_part_i/_part_i.html">
   I. Logic and Logic Programming
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../1_part_i/1.0.html">
     1. A brief introduction to clausal logic
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
    <label for="toctree-checkbox-3">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/1.1.html">
       1.1. Answering queries
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/1.2.html">
       1.2. Recursion
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/1.3.html">
       1.3. Structured terms
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/1.4.html">
       1.4. What else is there to know about clausal logic?
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../1_part_i/2.0.html">
     2. Clausal logic and resolution: theoretical backgrounds
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
    <label for="toctree-checkbox-4">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/2.1.html">
       2.1. Propositional clausal logic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/2.2.html">
       2.2. Relational clausal logic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/2.3.html">
       2.3. Full clausal logic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/2.4.html">
       2.4. Definite clause logic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/2.5.html">
       2.5. The relation between clausal logic and Predicate Logic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/2.6.html">
       2.6. Further reading
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../1_part_i/3.0.html">
     3. Logic Programming and Prolog
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
    <label for="toctree-checkbox-5">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.1.html">
       3.1. SLD-resolution
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.2.html">
       3.2. Pruning the search by means of cut
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.3.html">
       3.3. Negation as failure
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.4.html">
       3.4. Other uses of cut
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.5.html">
       3.5. Arithmetic expressions
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.6.html">
       3.6. Accumulators
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.7.html">
       3.7. Second-order predicates
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.8.html">
       3.8. Meta-programs
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.9.html">
       3.9. A methodology of Prolog programming
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.10.html">
       3.10. Further reading
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../2_part_ii/_part_ii.html">
   II. Reasoning with structured knowledge
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../2_part_ii/4.0.html">
     4. Representing structured knowledge
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
    <label for="toctree-checkbox-7">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../2_part_ii/4.1.html">
       4.1. Trees as terms
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../2_part_ii/4.2.html">
       4.2. Graphs generated by a predicate
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../2_part_ii/4.3.html">
       4.3. Inheritance hierarchies
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../2_part_ii/4.4.html">
       4.4. Further reading
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../2_part_ii/5.0.html">
     5. Searching graphs
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
    <label for="toctree-checkbox-8">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../2_part_ii/5.1.html">
       5.1. A general search procedure
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../2_part_ii/5.2.html">
       5.2. Depth-first search
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../2_part_ii/5.3.html">
       5.3. Breadth-first search
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../2_part_ii/5.4.html">
       5.4. Forward chaining
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../2_part_ii/5.5.html">
       5.5. Further reading
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../2_part_ii/6.0.html">
     6. Informed search
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
    <label for="toctree-checkbox-9">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../2_part_ii/6.1.html">
       6.1. Best-first search
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../2_part_ii/6.2.html">
       6.2. Optimal best-first search
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../2_part_ii/6.3.html">
       6.3. Non-exhaustive informed search
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../2_part_ii/6.4.html">
       6.4. Further reading
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="_part_iii.html">
   III. Advanced reasoning techniques
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="7.0.html">
     7. Reasoning with natural language
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
    <label for="toctree-checkbox-11">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="7.1.html">
       7.1. Grammars and parsing
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="7.2.html">
       7.2. Definite Clause Grammars
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="7.3.html">
       7.3. Interpretation of natural language
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="7.4.html">
       7.4. Further reading
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 current active has-children">
    <a class="reference internal" href="8.0.html">
     8. Reasoning with incomplete information
    </a>
    <input checked="" class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
    <label for="toctree-checkbox-12">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="current">
     <li class="toctree-l3">
      <a class="reference internal" href="8.1.html">
       8.1. Default reasoning
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="8.2.html">
       8.2. The semantics of incomplete information
      </a>
     </li>
     <li class="toctree-l3 current active">
      <a class="current reference internal" href="#">
       8.3. Abduction and diagnostic reasoning
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="8.4.html">
       8.4. The complete picture
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="8.5.html">
       8.5. Further reading
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="9.0.html">
     9. Inductive reasoning
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
    <label for="toctree-checkbox-13">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="9.1.html">
       9.1. Generalisation and specialisation
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="9.2.html">
       9.2. Bottom-up induction
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="9.3.html">
       9.3. Top-down induction
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="9.4.html">
       9.4. Further reading
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../appendices/_appendices.html">
   Appendices
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/>
  <label for="toctree-checkbox-14">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../appendices/a_0.html">
     10. A catalogue of useful predicates
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/>
    <label for="toctree-checkbox-15">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/a_1.html">
       10.1. Built-in predicates
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/a_2.html">
       10.2. A library of utility predicates
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../appendices/b_0.html">
     11. Two programs for logical conversion
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/>
    <label for="toctree-checkbox-16">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/b_1.html">
       11.1. From Predicate Logic to clausal logic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/b_2.html">
       11.2. Predicate Completion
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../appendices/c_0.html">
     12. Answers to selected exercises
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/>
    <label for="toctree-checkbox-17">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_1.html">
       12.1. A brief introduction to clausal logic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_2.html">
       12.2. Clausal logic and resolution: theoretical backgrounds
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_3.html">
       12.3. Logic Programming and Prolog
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_4.html">
       12.4. Representing structured knowledge
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_5.html">
       12.5. Searching graphs
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_6.html">
       12.6. Informed search
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_7.html">
       12.7. Reasoning with natural language
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_8.html">
       12.8. Reasoning with incomplete information
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_9.html">
       12.9. Inductive reasoning
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference external" href="https://simply-logical.space/">
   Simply Logical Organisation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference external" href="https://www.cs.bris.ac.uk/~flach/SimplyLogical.html">
   Original Book Home
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  <a href="https://doi.org/10.5281/zenodo.1156977"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.1156977.svg" alt="DOI"></a>

</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../../_sources/src/text/3_part_iii/8.3.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/simply-logical/simply-logical"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/simply-logical/simply-logical/issues/new?title=Issue%20on%20page%20%2Fsrc/text/3_part_iii/8.3.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/simply-logical/simply-logical/edit/master/src/text/3_part_iii/8.3.md"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Abduction and diagnostic reasoning</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            
              <div>
                
  <!--H3: Section 8.3-->
<div class="section" id="abduction-and-diagnostic-reasoning">
<span id="sec-8-3"></span><h1><span class="section-number">8.3. </span>Abduction and diagnostic reasoning<a class="headerlink" href="#abduction-and-diagnostic-reasoning" title="Permalink to this headline">¶</a></h1>
<p>Abduction extends default reasoning by not only making assumptions about what is false, but also about what is true. For instance, in the light bulb example given earlier, we know that if the light bulb is broken, the light doesn’t switch on. If we observe that the light doesn’t switch on, a possible explanation is that the light bulb is broken. Since this is only one of the possible explanations, it cannot be guaranteed to be true. For instance, there might be a problem with the power supply instead, or the switch might be broken.</p>
<p>The general problem of abduction can be stated as follows. Given a <span class="math notranslate nohighlight">\(Theory\)</span> and an <span class="math notranslate nohighlight">\(Observation\)</span>, find an <span class="math notranslate nohighlight">\(Explanation\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
Theory \cup Explanation \models Observation
\]</div>
<p>i.e. the <span class="math notranslate nohighlight">\(Observation\)</span> follows logically from the <span class="math notranslate nohighlight">\(Theory\)</span> extended with the <span class="math notranslate nohighlight">\(Explanation\)</span>. For instance, if <span class="math notranslate nohighlight">\(Theory\)</span> consists of the following clauses</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">likes</span><span class="p">(</span><span class="s s-Atom">peter</span><span class="p">,</span><span class="nv">S</span><span class="p">):-</span><span class="nf">student_of</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span><span class="s s-Atom">peter</span><span class="p">).</span>
<span class="nf">likes</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">):-</span><span class="nf">friend</span><span class="p">(</span><span class="nv">Y</span><span class="p">,</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>and we have the <span class="math notranslate nohighlight">\(Observation\)</span> <code class="docutils literal notranslate"><span class="pre">likes(peter,paul)</span></code>, then possible <span class="math notranslate nohighlight">\(Explanations\)</span> are <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">student_of(paul,peter)</span> <span class="pre">}</span></code> and <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">friend(paul,peter)</span> <span class="pre">}</span></code>.</p>
<p>Other <span class="math notranslate nohighlight">\(Explanations\)</span> which satisfy the problem specification are <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">likes(X,paul)</span> <span class="pre">}</span></code> and <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">likes(X,Y):-friendly(Y),</span> <span class="pre">friendly(paul)</span> <span class="pre">}</span></code>. However, abductive explanations are usually restricted to ground literals with predicates that are undefined in <span class="math notranslate nohighlight">\(Theory\)</span> (such literals are called <em>abducibles</em>). Inferring general rules from specific observations is called induction, and is discussed in the next chapter.</p>
<p>Procedurally, we can construct an abductive explanation by trying to prove the <span class="math notranslate nohighlight">\(Observation\)</span> from the initial <span class="math notranslate nohighlight">\(Theory\)</span> alone: whenever we encounter a literal for which there is no clause to resolve with, we add the literal to the <span class="math notranslate nohighlight">\(Explanation\)</span>. This leads to the following abductive meta-interpreter.</p>
<div class="extract swish highlight highlight-Prolog notranslate" id="swish-8-3-1">
<pre class="literal-block source swish" id="swish-8-3-1-code" source-text-end="
element(X,[X|_Ys]).
element(X,[_Y|Ys]):-
    element(X,Ys).

cl(likes(peter,S),student_of(S,peter)).
cl(likes(X,Y),friend(Y,X)).

cl(flies(X),(bird(X),not(abnormal(X)))).
cl(abnormal(X),penguin(X)).
cl(abnormal(X),dead(X)).
cl(bird(X),penguin(X)).
cl(bird(X),sparrow(X))." source-text-start=":-op(900,fy,not).

">
<span></span><span class="c1">% abduce(O,E) &lt;- observation O follows by SLD-resolution</span>
<span class="c1">%                from the theory defined by clause/2,</span>
<span class="c1">%                extended with a list of unit clauses E</span>
<span class="nf">abduce</span><span class="p">(</span><span class="nv">O</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">O</span><span class="p">,[],</span><span class="nv">E</span><span class="p">).</span>

<span class="c1">% with accumulator for explanations</span>
<span class="nf">abduce</span><span class="p">(</span><span class="s s-Atom">true</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">):-!.</span>
<span class="nf">abduce</span><span class="p">((</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-!,</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E1</span><span class="p">),</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">E1</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">cl</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span>  <span class="c1">% query clauses enumerated by cl/2</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">element</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,[</span><span class="nv">A</span><span class="p">|</span><span class="nv">E</span><span class="p">]):-</span>
    <span class="o">not</span> <span class="nf">element</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">),</span>
    <span class="nf">abducible</span><span class="p">(</span><span class="nv">A</span><span class="p">).</span>

<span class="nf">abducible</span><span class="p">(</span><span class="nv">A</span><span class="p">):-</span>
    <span class="o">not</span> <span class="nf">cl</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="k">_</span><span class="nv">B</span><span class="p">).</span><div class="hide-examples">

<span class="cm">/** &lt;examples&gt;</span>
<span class="cm">?- abduce(likes(peter,paul),Explanation).</span>
<span class="cm">?- abduce(flies(tweety),Explanation).</span>
<span class="cm">*/</span></div>
</pre></div>
<p>The last two clauses of <code class="docutils literal notranslate"><span class="pre">abduce/3</span></code> extend the original depth-first meta-interpreter. The program uses an accumulator containing the partial explanation found so far, such that literals are not unnecessarily duplicated in the final explanation. The query</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">abduce</span><span class="p">(</span><span class="nf">likes</span><span class="p">(</span><span class="s s-Atom">peter</span><span class="p">,</span><span class="s s-Atom">paul</span><span class="p">),</span><span class="nv">Explanation</span><span class="p">).</span>
</pre></div>
</div>
<p>results in the answers</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">Explanation</span> <span class="o">=</span> <span class="p">[</span><span class="nf">student_of</span><span class="p">(</span><span class="s s-Atom">paul</span><span class="p">,</span><span class="s s-Atom">peter</span><span class="p">)];</span>
<span class="nv">Explanation</span> <span class="o">=</span> <span class="p">[</span><span class="nf">friend</span><span class="p">(</span><span class="s s-Atom">paul</span><span class="p">,</span><span class="s s-Atom">peter</span><span class="p">)]</span>
</pre></div>
</div>
<p>Interestingly, this abductive meta-interpreter also works for general clauses, but it does not always produce correct explanations. For instance, suppose the initial <span class="math notranslate nohighlight">\(Theory\)</span> contains a general clause:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">flies</span><span class="p">(</span><span class="nv">X</span><span class="p">):-</span><span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span><span class="o">not</span> <span class="nf">abnormal</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">abnormal</span><span class="p">(</span><span class="nv">X</span><span class="p">):-</span><span class="nf">penguin</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">):-</span><span class="nf">penguin</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">):-</span><span class="nf">sparrow</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>If asked to explain <code class="docutils literal notranslate"><span class="pre">flies(tweety)</span></code>, the above program will try to find a clause explaining <code class="docutils literal notranslate"><span class="pre">not(abnormal(tweety))</span></code>; since there is no such clause, this negated literal will be added to the explanation. As a result, the program will give the following explanations:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">Explanation</span> <span class="o">=</span> <span class="p">[</span><span class="o">not</span> <span class="nf">abnormal</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="nf">penguin</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)];</span>
<span class="nv">Explanation</span> <span class="o">=</span> <span class="p">[</span><span class="o">not</span> <span class="nf">abnormal</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="nf">sparrow</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)]</span>
</pre></div>
</div>
<p>There are two problems with these explanations. First of all, the first explanation is inconsistent with the theory. Secondly, <code class="docutils literal notranslate"><span class="pre">abnormal/1</span></code> is not an abducible predicate, and should not appear in an abductive explanation. For these reasons, we have to deal explicitly with negated literals in our abduction program.</p>
<!--section 3.8-->
<p>As a first try, we can extend our abductive meta-interpreter with negation as failure, by adding the following clause (see also <a class="reference internal" href="../1_part_i/3.8.html#sec-3-8"><span class="std std-numref">Section 3.8</span></a>):</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">abduce</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>    <span class="c1">% E explains not(A)</span>
    <span class="o">not</span> <span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>  <span class="c1">% if E doesn&#39;t explain A</span>
</pre></div>
</div>
<p>In order to prevent the query <code class="docutils literal notranslate"><span class="pre">abducible(not(A))</span></code> from succeeding, we change the definition of <code class="docutils literal notranslate"><span class="pre">abducible/1</span></code> to</p>
<div class="extract swish highlight highlight-Prolog notranslate" id="swish-8-3-1-2">
<pre class="literal-block source swish" id="swish-8-3-1-2-code" source-text-end="
element(X,[X|_Ys]).
element(X,[_Y|Ys]):-
    element(X,Ys).

cl(likes(peter,S),student_of(S,peter)).
cl(likes(X,Y),friend(Y,X)).

cl(flies(X),(bird(X),not(abnormal(X)))).
cl(abnormal(X),penguin(X)).
cl(abnormal(X),dead(X)).
cl(bird(X),penguin(X)).
cl(bird(X),sparrow(X))." source-text-start=":-op(900,fy,not).

% abduce(O,E) &lt;- observation O follows by SLD-resolution
%                from the theory defined by clause/2,
%                extended with a list of unit clauses E
abduce(O,E) :-
    abduce(O,[],E).

% with accumulator for explanations
abduce(true,E,E):-!.
abduce((A,B),E0,E):-!,
    abduce(A,E0,E1),
    abduce(B,E1,E).
abduce(A,E0,E):-
    cl(A,B),  % query clauses enumerated by cl/2
    abduce(B,E0,E).
abduce(A,E,E):-
    element(A,E).
abduce(A,E,[A|E]):-
    not element(A,E),
    abducible(A).
abduce(not(A),E,E):-    % E explains not(A)
    not abduce(A,E,E).  % if E doesn't explain A

:- discontiguous cl/2.
cl(flies1(X),(not(abnormal(X),bird(X)))).

">
<span></span><span class="nf">abducible</span><span class="p">(</span><span class="nv">A</span><span class="p">):-</span>
    <span class="nv">A</span> <span class="s s-Atom">\=</span> <span class="o">not</span><span class="p">(</span><span class="nv">B</span><span class="p">),</span>
    <span class="o">not</span> <span class="nf">cl</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">).</span><div class="hide-examples">

<span class="cm">/** &lt;examples&gt;</span>
<span class="cm">?- abduce(flies(tweety),Explanation).</span>
<span class="cm">?- abduce(not(abnormal(tweety)),[penguin(tweety)],[penguin(tweety)]).</span>
<span class="cm">?- abduce(not(abnormal(tweety)),[],[]).</span>
<span class="cm">?- abduce(flies1(tweety),Explanation).</span>
<span class="cm">*/</span></div>
</pre></div>
<p>With this extended abductive meta-interpreter, the query</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">abduce</span><span class="p">(</span><span class="nf">flies</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="nv">Explanation</span><span class="p">).</span>
</pre></div>
</div>
<p>now results in the following, correct answer:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">Explanation</span> <span class="o">=</span> <span class="p">[</span><span class="nf">sparrow</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)]</span>
</pre></div>
</div>
<p>The explanation <code class="docutils literal notranslate"><span class="pre">[penguin(tweety)]</span></code> is found to be inconsistent, since</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">abduce</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nf">abnormal</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)),</span>
         <span class="p">[</span><span class="nf">penguin</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)],[</span><span class="nf">penguin</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)]).</span>
</pre></div>
</div>
<p>will fail, as it should.</p>
<p>However, this approach relies on the fact that negated literals are checked <strong>after</strong> the abductive explanation has been constructed. To illustrate this, suppose that <span class="math notranslate nohighlight">\(Theory\)</span> is extended with the following clause:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">flies1</span><span class="p">(</span><span class="nv">X</span><span class="p">):-</span><span class="o">not</span> <span class="nf">abnormal</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span><span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>Since</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">abduce</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nf">abnormal</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)),[],[]).</span>
</pre></div>
</div>
<p>succeeds, any explanation of <code class="docutils literal notranslate"><span class="pre">bird(tweety)</span></code> will also be an explanation of <code class="docutils literal notranslate"><span class="pre">flies1(tweety)</span></code>, which is of course wrong. The problem here is that the fact that <code class="docutils literal notranslate"><span class="pre">abnormal(tweety)</span></code> is considered to be <strong>false</strong> is not reflected in the explanation. Thus, we need a separate predicate <code class="docutils literal notranslate"><span class="pre">abduce_not/3</span></code> for building explanations for literals assumed to be false.</p>
<p>The full program is given below. There are two changes in <code class="docutils literal notranslate"><span class="pre">abduce/3</span></code>: in the fifth clause, an abducible <code class="docutils literal notranslate"><span class="pre">A</span></code> is only added to the explanation <code class="docutils literal notranslate"><span class="pre">E</span></code> if it is consistent with it; i.e. if <code class="docutils literal notranslate"><span class="pre">E</span></code> does not explain <code class="docutils literal notranslate"><span class="pre">not(A)</span></code>. In the sixth clause, an explicit explanation for <code class="docutils literal notranslate"><span class="pre">not(A)</span></code> is constructed.</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% abduce(O,E0,E) &lt;- E is abductive explanation of O, given</span>
<span class="c1">%                   E0 (works also for general programs)</span>
<span class="nf">abduce</span><span class="p">(</span><span class="s s-Atom">true</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">):-!.</span>
<span class="nf">abduce</span><span class="p">((</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-!,</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E1</span><span class="p">),</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">E1</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">clause</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">element</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>           <span class="c1">% already assumed</span>
<span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,[</span><span class="nv">A</span><span class="p">|</span><span class="nv">E</span><span class="p">]):-</span>         <span class="c1">% A can be added to E</span>
    <span class="o">not</span> <span class="nf">element</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">),</span>       <span class="c1">% if it&#39;s not already there,</span>
    <span class="nf">abducible</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>           <span class="c1">% if it&#39;s abducible,</span>
    <span class="o">not</span> <span class="nf">abduce_not</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>  <span class="c1">% and E doesn&#39;t explain not(A)</span>
<span class="nf">abduce</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>       <span class="c1">% find explanation for not(A)</span>
    <span class="o">not</span> <span class="nf">element</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">),</span>      <span class="c1">% should be consistent</span>
    <span class="nf">abduce_not</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
</pre></div>
</div>
<p>The definition of <code class="docutils literal notranslate"><span class="pre">abduce_not/3</span></code> closely mirrors the clauses for <code class="docutils literal notranslate"><span class="pre">abduce/3</span></code>:</p>
<!--roman list-->
<ol class="simple">
<li><p>a negated conjunction <code class="docutils literal notranslate"><span class="pre">not((A,B))</span></code> is explained by either explaining <code class="docutils literal notranslate"><span class="pre">not(A)</span></code> <strong>or</strong> <code class="docutils literal notranslate"><span class="pre">not(B)</span></code>;</p></li>
<li><p>if there are clauses for <code class="docutils literal notranslate"><span class="pre">A</span></code>, then <code class="docutils literal notranslate"><span class="pre">not(A)</span></code> is explained by constructing an explanation for <code class="docutils literal notranslate"><span class="pre">not(B)</span></code>, for <strong>every</strong> body <code class="docutils literal notranslate"><span class="pre">B</span></code>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">not(A)</span></code> is explained if it is already part of the explanation;</p></li>
<li><p>otherwise, <code class="docutils literal notranslate"><span class="pre">not(A)</span></code> is explained by itself, if <code class="docutils literal notranslate"><span class="pre">A</span></code> is abducible and not explained;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">not(not(A))</span></code> is explained by explaining <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p></li>
</ol>
<p>There is no clause for <code class="docutils literal notranslate"><span class="pre">true</span></code>, since <code class="docutils literal notranslate"><span class="pre">not(true)</span></code> cannot be explained.</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% abduce_not(O,E0,E) &lt;- E is abductive expl. of not(O)</span>
<span class="nf">abduce_not</span><span class="p">((</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-!,</span>
    <span class="nf">abduce_not</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">);</span>       <span class="c1">% disjunction</span>
    <span class="nf">abduce_not</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce_not</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">setof</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nf">clause</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span><span class="nv">L</span><span class="p">),</span>
    <span class="nf">abduce_not_l</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce_not</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">element</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nv">E</span><span class="p">).</span>        <span class="c1">% not(A) already assumed</span>
<span class="nf">abduce_not</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,[</span><span class="o">not</span><span class="p">(</span><span class="nv">A</span><span class="p">)|</span><span class="nv">E</span><span class="p">]):-</span>  <span class="c1">% not(A) can be added to E</span>
    <span class="o">not</span> <span class="nf">element</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nv">E</span><span class="p">),</span>    <span class="c1">% if it&#39;s not already there,</span>
    <span class="nf">abducible</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>             <span class="c1">% if A is abducible</span>
    <span class="o">not</span> <span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>        <span class="c1">% and E doesn&#39;t explain A</span>
<span class="nf">abduce_not</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>     <span class="c1">% find explanation for A</span>
    <span class="o">not</span> <span class="nf">element</span><span class="p">(</span><span class="o">not</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nv">E0</span><span class="p">),</span>   <span class="c1">% should be consistent</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>

<span class="nf">abduce_not_l</span><span class="p">([],</span><span class="nv">E</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
<span class="nf">abduce_not_l</span><span class="p">([</span><span class="nv">B</span><span class="p">|</span><span class="nv">Bs</span><span class="p">],</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E</span><span class="p">):-</span>
    <span class="nf">abduce_not</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">E0</span><span class="p">,</span><span class="nv">E1</span><span class="p">),</span>
    <span class="nf">abduce_not_l</span><span class="p">(</span><span class="nv">Bs</span><span class="p">,</span><span class="nv">E1</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
</pre></div>
</div>
<p>We illustrate the program on the following set of clauses. Notice that there are several explanations for <code class="docutils literal notranslate"><span class="pre">abnormal(tweety)</span></code>.</p>
<div class="extract swish highlight highlight-Prolog notranslate" id="swish-8-3-2">
<pre class="literal-block source swish" id="swish-8-3-2-code" source-text-end="
abducible(A):-
    A \= not(B),
    not cl(A,B)." source-text-start=":-op(900,fy,not).

abduce(O,E) :-abduce(O,[],E).

% abduce(O,E0,E) &lt;- E is abductive explanation of O, given
%                   E0 (works also for general programs)
abduce(true,E,E):-!.
abduce((A,B),E0,E):-!,
    abduce(A,E0,E1),
    abduce(B,E1,E).
abduce(A,E0,E):-
    cl(A,B),
    abduce(B,E0,E).
abduce(A,E,E):-
    element(A,E).           % already assumed
abduce(A,E,[A|E]):-
    not element(A,E),
    abducible(A),
    not abduce_not(A,E,E).  % and E doesn't explain not(A)
abduce(not(A),E0,E):-
    not element(A,E0),
    abduce_not(A,E0,E).

% abduce_not(O,E0,E) &lt;- E is abductive expl. of not(O)
abduce_not((A,B),E0,E):-!,
    abduce_not(A,E0,E);       % disjunction
    abduce_not(B,E0,E).
abduce_not(A,E0,E):-
    setof(B,cl(A,B),L),
    abduce_not_l(L,E0,E).
abduce_not(A,E,E):-
    element(not(A),E).        % not(A) already assumed
abduce_not(A,E,[not(A)|E]):-
    not element(not(A),E),
    abducible(A),
    not abduce(A,E,E).        % and E doesn't explain A
abduce_not(not(A),E0,E):-
    not element(not(A),E0),
    abduce(A,E0,E).

abduce_not_l([],E,E).
abduce_not_l([B|Bs],E0,E):-
    abduce_not(B,E0,E1),
    abduce_not_l(Bs,E1,E).

% element(X,Ys) &lt;- X is an element of the list Ys
element(X,[X|_Ys]).
element(X,[_Y|Ys]):-element(X,Ys).

">
<span></span><span class="nf">cl</span><span class="p">(</span><span class="nf">flies1</span><span class="p">(</span><span class="nv">X</span><span class="p">),(</span><span class="o">not</span><span class="p">(</span><span class="nf">abnormal</span><span class="p">(</span><span class="nv">X</span><span class="p">)),</span><span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">))).</span>
<span class="nf">cl</span><span class="p">(</span><span class="nf">flies</span><span class="p">(</span><span class="nv">X</span><span class="p">),(</span><span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span><span class="o">not</span><span class="p">(</span><span class="nf">abnormal</span><span class="p">(</span><span class="nv">X</span><span class="p">)))).</span>
<span class="nf">cl</span><span class="p">(</span><span class="nf">abnormal</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span><span class="nf">penguin</span><span class="p">(</span><span class="nv">X</span><span class="p">)).</span>
<span class="nf">cl</span><span class="p">(</span><span class="nf">abnormal</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span><span class="nf">dead</span><span class="p">(</span><span class="nv">X</span><span class="p">)).</span>
<span class="nf">cl</span><span class="p">(</span><span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span><span class="nf">penguin</span><span class="p">(</span><span class="nv">X</span><span class="p">)).</span>
<span class="nf">cl</span><span class="p">(</span><span class="nf">bird</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span><span class="nf">sparrow</span><span class="p">(</span><span class="nv">X</span><span class="p">)).</span><div class="hide-examples">

<span class="cm">/** &lt;examples&gt;</span>
<span class="cm">?- abduce(flies(tweety),Explanation).</span>
<span class="cm">?- abduce(flies1(tweety),Explanation).</span>
<span class="cm">*/</span></div>
</pre></div>
<p>The following queries show that the order of unnegated and negated literals in a clause only influences the order in which abducibles are added to the explanation, but not the explanation itself:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">abduce</span><span class="p">(</span><span class="nf">flies</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="nv">Explanation</span><span class="p">).</span>
<span class="nv">Explanation</span> <span class="o">=</span>
    <span class="p">[</span><span class="o">not</span> <span class="nf">penguin</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="o">not</span> <span class="nf">dead</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="nf">sparrow</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)]</span>

<span class="s s-Atom">?-</span><span class="nf">abduce</span><span class="p">(</span><span class="nf">flies1</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="nv">Explanation</span><span class="p">).</span>
<span class="nv">Explanation</span> <span class="o">=</span>
    <span class="p">[</span><span class="nf">sparrow</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="o">not</span> <span class="nf">penguin</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">),</span><span class="o">not</span> <span class="nf">dead</span><span class="p">(</span><span class="s s-Atom">tweety</span><span class="p">)]</span>
</pre></div>
</div>
<div class="admonition exercise" id="ex-8-4">
<p class="admonition-title"><span class="caption-number">Exercise 8.4 </span><a class="headerlink" href="#ex-8-4" title="Permalink to this exercise">¶</a></p>
<!--section 8.2-->
<p>The abductive meta-interpreter will loop on the program</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">wise</span><span class="p">(</span><span class="nv">X</span><span class="p">):-</span><span class="o">not</span> <span class="nf">teacher</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">teacher</span><span class="p">(</span><span class="s s-Atom">peter</span><span class="p">):-</span><span class="nf">wise</span><span class="p">(</span><span class="s s-Atom">peter</span><span class="p">).</span>
</pre></div>
</div>
<p>with the query <code class="docutils literal notranslate"><span class="pre">?-abduce(teacher(peter),E)</span></code> (see <a class="reference internal" href="8.2.html#sec-8-2"><span class="std std-numref">Section 8.2</span></a>). Change the interpreter such that this query is handled correctly, by adding <strong>all</strong> literals collected in the proof to the abductive explanation.</p>
</div>
<hr class="docutils" />
<p>Abduction can be used for formulating hypotheses about faulty components in a malfunctioning system. Here, the <span class="math notranslate nohighlight">\(Theory\)</span> is a description of the operation of the system, an <span class="math notranslate nohighlight">\(Observation\)</span> is a combination of input values and the observed output values, and <span class="math notranslate nohighlight">\(Explanation\)</span> is a <em>diagnosis</em>, telling us which components are malfunctioning. As an example we consider a logical circuit for adding three binary digits. Such a circuit can be built from two XOR-gates, two AND-gates, and an OR-gate (<a class="reference internal" href="#fig-8-3"><span class="std std-numref">Figure 8.3</span></a>). Its behaviour can be described logically as follows:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">adder</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">,</span><span class="nv">Sum</span><span class="p">,</span><span class="nv">Carry</span><span class="p">):-</span>
    <span class="nf">xor</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">S</span><span class="p">),</span>
    <span class="nf">xor</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span><span class="nv">S</span><span class="p">,</span><span class="nv">Sum</span><span class="p">),</span>
    <span class="nf">and</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">C1</span><span class="p">),</span>
    <span class="nf">and</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span><span class="nv">S</span><span class="p">,</span><span class="nv">C2</span><span class="p">),</span>
    <span class="nf">or</span><span class="p">(</span><span class="nv">C1</span><span class="p">,</span><span class="nv">C2</span><span class="p">,</span><span class="nv">Carry</span><span class="p">).</span>

<span class="nf">xor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span>        <span class="nf">and</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span>        <span class="nf">or</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span>
<span class="nf">xor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>        <span class="nf">and</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span>        <span class="nf">or</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>
<span class="nf">xor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>        <span class="nf">and</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span>        <span class="nf">or</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>
<span class="nf">xor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span>        <span class="nf">and</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>        <span class="nf">or</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>
</pre></div>
</div>
<div class="figure align-default" id="fig-8-3">
<a class="reference internal image-reference" href="../../../_images/image0122.svg"><img alt="../../../_images/image0122.svg" src="../../../_images/image0122.svg" width="75%" /></a>
<p class="caption"><span class="caption-number">Figure 8.3 </span><span class="caption-text">A 3-bit adder.</span><a class="headerlink" href="#fig-8-3" title="Permalink to this image">¶</a></p>
</div>
<p>These clauses describe the normal operation of the system. However, since diagnosis deals with faulty operation of components, we have to extend the system description with a so-called <em>fault model</em>. Such a fault model describes the behaviour of each component when it is in a faulty state. We distinguish two faulty states: the output of a component can be stuck at 0, or it can be stuck at 1. Faulty states are expressed by literals of the form <code class="docutils literal notranslate"><span class="pre">fault(Name=State)</span></code>, where <code class="docutils literal notranslate"><span class="pre">State</span></code> is either <code class="docutils literal notranslate"><span class="pre">s0</span></code> (stuck at 0) or <code class="docutils literal notranslate"><span class="pre">s1</span></code> (stuck at 1). The <code class="docutils literal notranslate"><span class="pre">Name</span></code> of a component is given by the system that contains it. Since components might be nested (e.g. the adder might itself be part of a circuit that adds two 8-bits binary numbers), the names of the components of a sub-system are prefixed by the name of that sub-system. This results in the following system description:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">adder</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">,</span><span class="nv">Sum</span><span class="p">,</span><span class="nv">Carry</span><span class="p">):-</span>
    <span class="nf">xorg</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="s s-Atom">xor1</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">S</span><span class="p">),</span>
    <span class="nf">xorg</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="p">,</span><span class="nv">Z</span><span class="p">,</span><span class="nv">S</span><span class="p">,</span><span class="nv">Sum</span><span class="p">),</span>
    <span class="nf">andg</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="s s-Atom">and1</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">C1</span><span class="p">),</span>
    <span class="nf">andg</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="s s-Atom">and2</span><span class="p">,</span><span class="nv">Z</span><span class="p">,</span><span class="nv">S</span><span class="p">,</span><span class="nv">C2</span><span class="p">),</span>
    <span class="nf">org</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="s s-Atom">or1</span><span class="p">,</span><span class="nv">C1</span><span class="p">,</span><span class="nv">C2</span><span class="p">,</span><span class="nv">Carry</span><span class="p">).</span>

<span class="nf">xorg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">):-</span><span class="nf">xor</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">).</span>
<span class="nf">xorg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">).</span>
<span class="nf">xorg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">).</span>
<span class="nf">xorg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">).</span>
<span class="nf">xorg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">).</span>

<span class="nf">andg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">):-</span><span class="nf">and</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">).</span>
<span class="nf">andg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">).</span>
<span class="nf">andg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">).</span>
<span class="nf">andg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">).</span>
<span class="nf">andg</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">).</span>

<span class="nf">org</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">):-</span><span class="nf">or</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">Z</span><span class="p">).</span>
<span class="nf">org</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">).</span>
<span class="nf">org</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">).</span>
<span class="nf">org</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">).</span>
<span class="nf">org</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):-</span><span class="nf">fault</span><span class="p">(</span><span class="nv">N</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">).</span>
</pre></div>
</div>
<p>Such a fault model, which includes all possible faulty behaviours, is called a <em>strong</em> fault model.</p>
<p>In order to diagnose the system, we declare <code class="docutils literal notranslate"><span class="pre">fault/1</span></code> as the (only) abducible predicate, and we make a call to <code class="docutils literal notranslate"><span class="pre">abduce/2</span></code>:</p>
<div class="extract swish highlight highlight-Prolog notranslate" id="swish-8-3-2-2">
<pre class="literal-block source swish" id="swish-8-3-2-2-code" source-text-end="
cl(A,B):-clause(A,B). 

adder(N,X,Y,Z,Sum,Carry):-
    xorg(N-xor1,X,Y,S),
    xorg(N-xor2,Z,S,Sum),
    andg(N-and1,X,Y,C1),
    andg(N-and2,Z,S,C2),
    org(N-or1,C1,C2,Carry).

xorg(_N,X,Y,Z):-xor(X,Y,Z).
xorg(N,0,0,1):-fault(N=s1).
xorg(N,0,1,0):-fault(N=s0).
xorg(N,1,0,0):-fault(N=s0).
xorg(N,1,1,1):-fault(N=s1).

andg(_N,X,Y,Z):-and(X,Y,Z).
andg(N,0,0,1):-fault(N=s1).
andg(N,0,1,1):-fault(N=s1).
andg(N,1,0,1):-fault(N=s1).
andg(N,1,1,0):-fault(N=s0).

org(_N,X,Y,Z):-or(X,Y,Z).
org(N,0,0,1):-fault(N=s1).
org(N,0,1,0):-fault(N=s0).
org(N,1,0,0):-fault(N=s0).
org(N,1,1,0):-fault(N=s0).

xor(0,0,0).
xor(0,1,1).
xor(1,0,1).
xor(1,1,0).
or(0,0,0).
or(0,1,1).
or(1,0,1).
or(1,1,1).
and(0,0,0).
and(0,1,0).
and(1,0,0).
and(1,1,1)." source-text-start=":-op(900,fy,not).

abduce(O,E) :-abduce(O,[],E).

% abduce(O,E0,E) &lt;- E is abductive explanation of O, given
%                   E0 (works also for general programs)
abduce(true,E,E):-!.
abduce((A,B),E0,E):-!,
    abduce(A,E0,E1),
    abduce(B,E1,E).
abduce(A,E0,E):-
    cl(A,B),
    abduce(B,E0,E).
abduce(A,E,E):-
    element(A,E).           % already assumed
abduce(A,E,[A|E]):-
    not element(A,E),
    abducible(A),
    not abduce_not(A,E,E).  % and E doesn't explain not(A)
abduce(not(A),E0,E):-
    not element(A,E0),
    abduce_not(A,E0,E).

% abduce_not(O,E0,E) &lt;- E is abductive expl. of not(O)
abduce_not((A,B),E0,E):-!,
    abduce_not(A,E0,E);       % disjunction
    abduce_not(B,E0,E).
abduce_not(A,E0,E):-
    setof(B,cl(A,B),L),
    abduce_not_l(L,E0,E).
abduce_not(A,E,E):-
    element(not(A),E).        % not(A) already assumed
abduce_not(A,E,[not(A)|E]):-
    not element(not(A),E),
    abducible(A),
    not abduce(A,E,E).        % and E doesn't explain A
abduce_not(not(A),E0,E):-
    not element(not(A),E0),
    abduce(A,E0,E).

abduce_not_l([],E,E).
abduce_not_l([B|Bs],E0,E):-
    abduce_not(B,E0,E1),
    abduce_not_l(Bs,E1,E).

% element(X,Ys) &lt;- X is an element of the list Ys
element(X,[X|_Ys]).
element(X,[_Y|Ys]):-element(X,Ys).

">
<span></span><span class="nf">diagnosis</span><span class="p">(</span><span class="nv">Observation</span><span class="p">,</span><span class="nv">Diagnosis</span><span class="p">):-</span>
    <span class="nf">abduce</span><span class="p">(</span><span class="nv">Observation</span><span class="p">,</span><span class="nv">Diagnosis</span><span class="p">).</span>

<span class="nf">abducible</span><span class="p">(</span><span class="nf">fault</span><span class="p">(</span><span class="k">_</span><span class="nv">X</span><span class="p">)).</span><div class="hide-examples">

<span class="cm">/** &lt;examples&gt;</span>
<span class="cm">?- diagnosis(adder(a,0,0,1,0,1),D).</span>
<span class="cm">*/</span></div>
</pre></div>
<p>For instance, suppose the inputs <code class="docutils literal notranslate"><span class="pre">X=0</span></code>, <code class="docutils literal notranslate"><span class="pre">Y=0</span></code> and <code class="docutils literal notranslate"><span class="pre">Z=1</span></code> result in the outputs <code class="docutils literal notranslate"><span class="pre">Sum=0</span></code> and <code class="docutils literal notranslate"><span class="pre">Carry=1</span></code> (a double fault). In order to diagnose this behaviour, we formulate the following query:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">diagnosis</span><span class="p">(</span><span class="nf">adder</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="nv">D</span><span class="p">).</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">or1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and2</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and2</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">or1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">)];</span>
<span class="nv">No</span> <span class="s s-Atom">more</span> <span class="s s-Atom">solutions</span>
</pre></div>
</div>
<p>The first diagnosis is very obvious: it states that <code class="docutils literal notranslate"><span class="pre">or1</span></code> (which calculates <code class="docutils literal notranslate"><span class="pre">Carry</span></code>) is stuck at 1, and <code class="docutils literal notranslate"><span class="pre">xor2</span></code> (which calculates <code class="docutils literal notranslate"><span class="pre">Sum</span></code>) is stuck at 0. But the fault in the output of <code class="docutils literal notranslate"><span class="pre">or1</span></code> might also be caused by <code class="docutils literal notranslate"><span class="pre">and2</span></code> or <code class="docutils literal notranslate"><span class="pre">and1</span></code>, and even by both! The fifth diagnosis is an interesting one: if <code class="docutils literal notranslate"><span class="pre">xor1</span></code> is stuck at 1, this accounts for <strong>both</strong> faults in the outputs of the adder. The remaining three diagnoses are considerably less interesting, since each of them makes unnecessary assumptions about additional faulty components.</p>
<p>The predicate <code class="docutils literal notranslate"><span class="pre">diagnosis/2</span></code> generates every possible diagnosis; it does not make any assumptions about the relative plausibility of each of them. Several such assumptions can be made. For instance, we might be interested in the diagnoses with the least number of faulty components (there is only one smallest diagnosis in the example, but there may be several in general). Alternatively, we might want to consider only non-redundant or <em>minimal</em> diagnoses: those of which no proper subset is also a diagnosis. This is readily expressed in Prolog:</p>
<div class="extract swish highlight highlight-Prolog notranslate" id="swish-8-3-2-3">
<pre class="literal-block source swish" id="swish-8-3-2-3-code" source-text-end="
diagnosis(Observation,Diagnosis):-
    abduce(Observation,Diagnosis).

abducible(fault(_X)).

cl(A,B):-clause(A,B). 

% remove_one(X,Ys,Zs) &lt;- Zs is list Ys minus one occurrence of X
remove_one(X,[X|Ys],Ys).
remove_one(X,[Y|Ys],[Y|Zs]):-remove_one(X,Ys,Zs).

% proper_subset(Xs,Ys) &lt;- Xs is a subset of Ys, and Ys contains
%                         at least one element more
proper_subset([],Ys):-Ys \= [].
proper_subset([X|Xs],Ys):-remove_one(X,Ys,Ys1),proper_subset(Xs,Ys1).

adder(N,X,Y,Z,Sum,Carry):-
    xorg(N-xor1,X,Y,S),
    xorg(N-xor2,Z,S,Sum),
    andg(N-and1,X,Y,C1),
    andg(N-and2,Z,S,C2),
    org(N-or1,C1,C2,Carry).

xorg(_N,X,Y,Z):-xor(X,Y,Z).
xorg(N,0,0,1):-fault(N=s1).
xorg(N,0,1,0):-fault(N=s0).
xorg(N,1,0,0):-fault(N=s0).
xorg(N,1,1,1):-fault(N=s1).

andg(_N,X,Y,Z):-and(X,Y,Z).
andg(N,0,0,1):-fault(N=s1).
andg(N,0,1,1):-fault(N=s1).
andg(N,1,0,1):-fault(N=s1).
andg(N,1,1,0):-fault(N=s0).

org(_N,X,Y,Z):-or(X,Y,Z).
org(N,0,0,1):-fault(N=s1).
org(N,0,1,0):-fault(N=s0).
org(N,1,0,0):-fault(N=s0).
org(N,1,1,0):-fault(N=s0).

xor(0,0,0).
xor(0,1,1).
xor(1,0,1).
xor(1,1,0).
or(0,0,0).
or(0,1,1).
or(1,0,1).
or(1,1,1).
and(0,0,0).
and(0,1,0).
and(1,0,0).
and(1,1,1)." source-text-start=":-op(900,fy,not).

abduce(O,E) :-abduce(O,[],E).

% abduce(O,E0,E) &lt;- E is abductive explanation of O, given
%                   E0 (works also for general programs)
abduce(true,E,E):-!.
abduce((A,B),E0,E):-!,
    abduce(A,E0,E1),
    abduce(B,E1,E).
abduce(A,E0,E):-
    cl(A,B),
    abduce(B,E0,E).
abduce(A,E,E):-
    element(A,E).           % already assumed
abduce(A,E,[A|E]):-
    not element(A,E),
    abducible(A),
    not abduce_not(A,E,E).  % and E doesn't explain not(A)
abduce(not(A),E0,E):-
    not element(A,E0),
    abduce_not(A,E0,E).

% abduce_not(O,E0,E) &lt;- E is abductive expl. of not(O)
abduce_not((A,B),E0,E):-!,
    abduce_not(A,E0,E);       % disjunction
    abduce_not(B,E0,E).
abduce_not(A,E0,E):-
    setof(B,cl(A,B),L),
    abduce_not_l(L,E0,E).
abduce_not(A,E,E):-
    element(not(A),E).        % not(A) already assumed
abduce_not(A,E,[not(A)|E]):-
    not element(not(A),E),
    abducible(A),
    not abduce(A,E,E).        % and E doesn't explain A
abduce_not(not(A),E0,E):-
    not element(not(A),E0),
    abduce(A,E0,E).

abduce_not_l([],E,E).
abduce_not_l([B|Bs],E0,E):-
    abduce_not(B,E0,E1),
    abduce_not_l(Bs,E1,E).

% element(X,Ys) &lt;- X is an element of the list Ys
element(X,[X|_Ys]).
element(X,[_Y|Ys]):-element(X,Ys).

">
<span></span><span class="nf">min_diagnosis</span><span class="p">(</span><span class="nv">O</span><span class="p">,</span><span class="nv">D</span><span class="p">):-</span>
    <span class="nf">diagnosis</span><span class="p">(</span><span class="nv">O</span><span class="p">,</span><span class="nv">D</span><span class="p">),</span>
    <span class="o">not</span><span class="p">((</span><span class="nf">diagnosis</span><span class="p">(</span><span class="nv">O</span><span class="p">,</span><span class="nv">D1</span><span class="p">),</span><span class="nf">proper_subset</span><span class="p">(</span><span class="nv">D1</span><span class="p">,</span><span class="nv">D</span><span class="p">))).</span><div class="hide-examples">

<span class="cm">/** &lt;examples&gt;</span>
<span class="cm">?- min_diagnosis(adder(a,0,0,1,0,1),D).</span>
<span class="cm">*/</span></div>
</pre></div>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">min_diagnosis</span><span class="p">(</span><span class="nf">adder</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="nv">D</span><span class="p">).</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">or1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and2</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">and1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">),</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor2</span><span class="o">=</span><span class="s s-Atom">s0</span><span class="p">)];</span>
<span class="nv">D</span> <span class="o">=</span> <span class="p">[</span><span class="nf">fault</span><span class="p">(</span><span class="s s-Atom">a</span><span class="o">-</span><span class="s s-Atom">xor1</span><span class="o">=</span><span class="s s-Atom">s1</span><span class="p">)];</span>
<span class="nv">No</span> <span class="s s-Atom">more</span> <span class="s s-Atom">solutions</span>
</pre></div>
</div>
<p>It should be noted that the predicate <code class="docutils literal notranslate"><span class="pre">min_diagnosis/2</span></code> is quite inefficient, since it needs time quadratic in the number of diagnoses (for each possible diagnosis, it generates in the worst case each possible diagnosis to see if the second is a proper subset of the first). In turn, the number of diagnoses is exponential in the number of components. More efficient ways of generating minimal diagnoses can be found in the literature; they fall outside the scope of this book.</p>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./src/text/3_part_iii"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

    <script>$(function() { $(".swish").LPN({swish:"https://swish.simply-logical.space/"}); });</script>


              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="8.2.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">8.2. </span>The semantics of incomplete information</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="8.4.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">8.4. </span>The complete picture</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By <a href="mailto:Peter.Flach@bristol.ac.uk">Peter Flach</a> and <a href="mailto:K.Sokol@bristol.ac.uk">Kacper Sokol</a>, University of Bristol, United Kingdom
<br/>
    
        &copy; Copyright 2015–2021.<br/>
      <div class="extra_footer">
        <p> This work is licenced under the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licence</a>. </p> <p> This book discusses methods to implement intelligent reasoning by means of Prolog programs. The book is written from the shared viewpoints of Computational Logic, which aims at automating various kinds of reasoning, and Artificial Intelligence, which seeks to implement aspects of intelligent behaviour on a computer. </p>

      </div>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>