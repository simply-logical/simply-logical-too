
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>5.2. Depth-first search &#8212; Simply Logical:&lt;br&gt;Intelligent Reasoning by Example</title>
    
  <link href="../../../_static/css/theme.css" rel="stylesheet">
  <link href="../../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-prolog.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/lpn.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jquery-ui.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sl.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/lpn.js"></script>
    <script src="../../../_static/jquery-ui.min.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="5.3. Breadth-first search" href="5.3.html" />
    <link rel="prev" title="5.1. A general search procedure" href="5.1.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-112595762-2', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../_static/SL.svg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Simply Logical:<br>Intelligent Reasoning by Example</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../simply-logical.html">
   Simply Logical
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../0_preface/_preface.html">
   Preface to the online edition
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../0_preface/glossary.html">
     Glossary
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../1_part_i/_part_i.html">
   I. Logic and Logic Programming
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../1_part_i/1.0.html">
     1. A brief introduction to clausal logic
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
    <label for="toctree-checkbox-3">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/1.1.html">
       1.1. Answering queries
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/1.2.html">
       1.2. Recursion
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/1.3.html">
       1.3. Structured terms
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/1.4.html">
       1.4. What else is there to know about clausal logic?
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../1_part_i/2.0.html">
     2. Clausal logic and resolution: theoretical backgrounds
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
    <label for="toctree-checkbox-4">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/2.1.html">
       2.1. Propositional clausal logic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/2.2.html">
       2.2. Relational clausal logic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/2.3.html">
       2.3. Full clausal logic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/2.4.html">
       2.4. Definite clause logic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/2.5.html">
       2.5. The relation between clausal logic and Predicate Logic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/2.6.html">
       2.6. Further reading
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../1_part_i/3.0.html">
     3. Logic Programming and Prolog
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
    <label for="toctree-checkbox-5">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.1.html">
       3.1. SLD-resolution
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.2.html">
       3.2. Pruning the search by means of cut
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.3.html">
       3.3. Negation as failure
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.4.html">
       3.4. Other uses of cut
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.5.html">
       3.5. Arithmetic expressions
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.6.html">
       3.6. Accumulators
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.7.html">
       3.7. Second-order predicates
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.8.html">
       3.8. Meta-programs
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.9.html">
       3.9. A methodology of Prolog programming
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../1_part_i/3.10.html">
       3.10. Further reading
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="_part_ii.html">
   II. Reasoning with structured knowledge
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="4.0.html">
     4. Representing structured knowledge
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
    <label for="toctree-checkbox-7">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="4.1.html">
       4.1. Trees as terms
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="4.2.html">
       4.2. Graphs generated by a predicate
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="4.3.html">
       4.3. Inheritance hierarchies
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="4.4.html">
       4.4. Further reading
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 current active has-children">
    <a class="reference internal" href="5.0.html">
     5. Searching graphs
    </a>
    <input checked="" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
    <label for="toctree-checkbox-8">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="current">
     <li class="toctree-l3">
      <a class="reference internal" href="5.1.html">
       5.1. A general search procedure
      </a>
     </li>
     <li class="toctree-l3 current active">
      <a class="current reference internal" href="#">
       5.2. Depth-first search
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="5.3.html">
       5.3. Breadth-first search
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="5.4.html">
       5.4. Forward chaining
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="5.5.html">
       5.5. Further reading
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="6.0.html">
     6. Informed search
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
    <label for="toctree-checkbox-9">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="6.1.html">
       6.1. Best-first search
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="6.2.html">
       6.2. Optimal best-first search
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="6.3.html">
       6.3. Non-exhaustive informed search
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="6.4.html">
       6.4. Further reading
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../3_part_iii/_part_iii.html">
   III. Advanced reasoning techniques
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../3_part_iii/7.0.html">
     7. Reasoning with natural language
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
    <label for="toctree-checkbox-11">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../3_part_iii/7.1.html">
       7.1. Grammars and parsing
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../3_part_iii/7.2.html">
       7.2. Definite Clause Grammars
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../3_part_iii/7.3.html">
       7.3. Interpretation of natural language
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../3_part_iii/7.4.html">
       7.4. Further reading
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../3_part_iii/8.0.html">
     8. Reasoning with incomplete information
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
    <label for="toctree-checkbox-12">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../3_part_iii/8.1.html">
       8.1. Default reasoning
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../3_part_iii/8.2.html">
       8.2. The semantics of incomplete information
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../3_part_iii/8.3.html">
       8.3. Abduction and diagnostic reasoning
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../3_part_iii/8.4.html">
       8.4. The complete picture
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../3_part_iii/8.5.html">
       8.5. Further reading
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../3_part_iii/9.0.html">
     9. Inductive reasoning
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
    <label for="toctree-checkbox-13">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../3_part_iii/9.1.html">
       9.1. Generalisation and specialisation
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../3_part_iii/9.2.html">
       9.2. Bottom-up induction
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../3_part_iii/9.3.html">
       9.3. Top-down induction
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../3_part_iii/9.4.html">
       9.4. Further reading
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../appendices/_appendices.html">
   Appendices
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/>
  <label for="toctree-checkbox-14">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../appendices/a_0.html">
     10. A catalogue of useful predicates
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/>
    <label for="toctree-checkbox-15">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/a_1.html">
       10.1. Built-in predicates
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/a_2.html">
       10.2. A library of utility predicates
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../appendices/b_0.html">
     11. Two programs for logical conversion
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/>
    <label for="toctree-checkbox-16">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/b_1.html">
       11.1. From Predicate Logic to clausal logic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/b_2.html">
       11.2. Predicate Completion
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../appendices/c_0.html">
     12. Answers to selected exercises
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/>
    <label for="toctree-checkbox-17">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_1.html">
       12.1. A brief introduction to clausal logic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_2.html">
       12.2. Clausal logic and resolution: theoretical backgrounds
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_3.html">
       12.3. Logic Programming and Prolog
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_4.html">
       12.4. Representing structured knowledge
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_5.html">
       12.5. Searching graphs
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_6.html">
       12.6. Informed search
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_7.html">
       12.7. Reasoning with natural language
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_8.html">
       12.8. Reasoning with incomplete information
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../appendices/c_9.html">
       12.9. Inductive reasoning
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference external" href="https://simply-logical.space/">
   Simply Logical Organisation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference external" href="https://www.cs.bris.ac.uk/~flach/SimplyLogical.html">
   Original Book Home
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  <a href="https://doi.org/10.5281/zenodo.1156977"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.1156977.svg" alt="DOI"></a>

</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../../_sources/src/text/2_part_ii/5.2.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/simply-logical/simply-logical"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/simply-logical/simply-logical/issues/new?title=Issue%20on%20page%20%2Fsrc/text/2_part_ii/5.2.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/simply-logical/simply-logical/edit/master/src/text/2_part_ii/5.2.md"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <!--H3: Section 5.2-->
<div class="section" id="depth-first-search">
<span id="sec-5-2"></span><h1><span class="section-number">5.2. </span>Depth-first search<a class="headerlink" href="#depth-first-search" title="Permalink to this headline">¶</a></h1>
<p>We obtain a depth-first search strategy if the agenda is implemented as a last in–first out datastructure. The obvious way to do this in Prolog is to represent the agenda by a list of nodes, and to add and remove nodes from the front of the list:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% depth-first search</span>
<span class="nf">search_df</span><span class="p">([</span><span class="nv">Goal</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">goal</span><span class="p">(</span><span class="nv">Goal</span><span class="p">).</span>
<span class="nf">search_df</span><span class="p">([</span><span class="nv">Current</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">children</span><span class="p">(</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Children</span><span class="p">),</span>
    <span class="nf">append</span><span class="p">(</span><span class="nv">Children</span><span class="p">,</span><span class="nv">Rest</span><span class="p">,</span><span class="nv">NewAgenda</span><span class="p">),</span>
    <span class="nf">search_df</span><span class="p">(</span><span class="nv">NewAgenda</span><span class="p">,</span><span class="nv">Goal</span><span class="p">).</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">children/2</span></code> predicate finds all children of a given node. If arcs in the search space are defined as before by the <code class="docutils literal notranslate"><span class="pre">arc/2</span></code> predicate, we could define <code class="docutils literal notranslate"><span class="pre">children/2</span></code> as</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">children</span><span class="p">(</span><span class="nv">Node</span><span class="p">,</span><span class="nv">Children</span><span class="p">):-</span>
    <span class="nf">findall</span><span class="p">(</span><span class="nv">C</span><span class="p">,</span><span class="nf">arc</span><span class="p">(</span><span class="nv">Node</span><span class="p">,</span><span class="nv">C</span><span class="p">),</span><span class="nv">Children</span><span class="p">).</span>
</pre></div>
</div>
<p>In this way, all children of the current node are generated and stored on the agenda before examining the next node.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Here is an example of using depth-first search to find palindromes ending in a given series of letters.
(This is just for illustrative purposes, as a much better algorithm would be to extend the given letters with a prefix, reverse the extended string and append the two together.)
Note the depth bound is needed to get any answers at all.</p>
<div class="extract swish highlight highlight-Prolog notranslate" id="swish-search-df">
<pre class="literal-block source swish" id="swish-search-df-code" source-text-start="search_df([Goal|_Rest],Goal):-
    goal(Goal).
search_df([Current|Rest],Goal):-
    children(Current,Children),
    append(Children,Rest,NewAgenda),
    search_df(NewAgenda,Goal).

children(Node,Children):-
    findall(C,arc(Node,C),Children).

">
<span></span><span class="c1">% nodes are lists of letters</span>
<span class="nf">arc</span><span class="p">(</span><span class="nv">T</span><span class="p">,[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">]):-</span>
    <span class="nf">length</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span><span class="nv">N</span><span class="p">),</span><span class="nv">N</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">,</span>     <span class="c1">% this sets a depth bound</span>
    <span class="nf">member</span><span class="p">(</span><span class="nv">H</span><span class="p">,[</span><span class="s s-Atom">a</span><span class="p">,</span><span class="s s-Atom">d</span><span class="p">,</span><span class="s s-Atom">i</span><span class="p">,</span><span class="s s-Atom">m</span><span class="p">]).</span>  <span class="c1">% only use these letters</span>

<span class="c1">% find palindromes</span>
<span class="nf">goal</span><span class="p">(</span><span class="nv">L</span><span class="p">):-</span>
    <span class="nf">reverse</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span><span class="nv">L</span><span class="p">).</span><div class="hide-examples">

<span class="cm">/** &lt;examples&gt;</span>
<span class="cm">?-search_df([[a,d,a,m]],Goal).</span>
<span class="cm">*/</span></div>
</pre></div>
</div>
<p>This depth-first search program can be refined in several ways, of which we will consider two: returning a path to the goal, and loop detection. In the above implementation, it is impossible to return a path if we discover a goal node on the agenda, because we do not know how that goal node was reached. Instead of putting a single node on the agenda, we will store a complete path to that node. This is simply accomplished by changing the <code class="docutils literal notranslate"><span class="pre">children/2</span></code> predicate as follows:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">children</span><span class="p">([</span><span class="nv">Node</span><span class="p">|</span><span class="nv">Path</span><span class="p">],</span><span class="nv">Children</span><span class="p">):-</span>
    <span class="nf">findall</span><span class="p">([</span><span class="nv">C</span><span class="p">,</span><span class="nv">Node</span><span class="p">|</span><span class="nv">Path</span><span class="p">],</span><span class="nf">arc</span><span class="p">(</span><span class="nv">Node</span><span class="p">,</span><span class="nv">C</span><span class="p">),</span><span class="nv">Children</span><span class="p">).</span>
</pre></div>
</div>
<p>Of course, the <code class="docutils literal notranslate"><span class="pre">goal/1</span></code> predicate must be changed accordingly, because its argument is now a path instead of a single node. A query now takes the form</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">search_df</span><span class="p">([[</span><span class="nv">InitialNode</span><span class="p">]],</span><span class="nv">PathToGoal</span><span class="p">).</span>
</pre></div>
</div>
<p>The second refinement concerns loop detection. In order to check whether a node has been investigated before, we must maintain a list of visited nodes. We only add nodes to the agenda which do not already occur on this list (or on the agenda):</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% depth-first search with loop detection</span>
<span class="nf">search_df_loop</span><span class="p">([</span><span class="nv">Goal</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">goal</span><span class="p">(</span><span class="nv">Goal</span><span class="p">).</span>
<span class="nf">search_df_loop</span><span class="p">([</span><span class="nv">Current</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">children</span><span class="p">(</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Children</span><span class="p">),</span>
    <span class="nf">add_df</span><span class="p">(</span><span class="nv">Children</span><span class="p">,</span><span class="nv">Rest</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">NewAgenda</span><span class="p">),</span>
    <span class="nf">search_df_loop</span><span class="p">(</span><span class="nv">NewAgenda</span><span class="p">,[</span><span class="nv">Current</span><span class="p">|</span><span class="nv">Visited</span><span class="p">],</span><span class="nv">Goal</span><span class="p">).</span>

<span class="nf">add_df</span><span class="p">([],</span><span class="nv">Agenda</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">Agenda</span><span class="p">).</span>
<span class="nf">add_df</span><span class="p">([</span><span class="nv">Child</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span><span class="nv">OldAgenda</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,[</span><span class="nv">Child</span><span class="p">|</span><span class="nv">NewAgenda</span><span class="p">]):-</span>
    <span class="o">not</span> <span class="nf">element</span><span class="p">(</span><span class="nv">Child</span><span class="p">,</span><span class="nv">OldAgenda</span><span class="p">),</span>
    <span class="o">not</span> <span class="nf">element</span><span class="p">(</span><span class="nv">Child</span><span class="p">,</span><span class="nv">Visited</span><span class="p">),</span>
    <span class="nf">add_df</span><span class="p">(</span><span class="nv">Rest</span><span class="p">,</span><span class="nv">OldAgenda</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">NewAgenda</span><span class="p">).</span>
<span class="nf">add_df</span><span class="p">([</span><span class="nv">Child</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span><span class="nv">OldAgenda</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">NewAgenda</span><span class="p">):-</span>
    <span class="nf">element</span><span class="p">(</span><span class="nv">Child</span><span class="p">,</span><span class="nv">OldAgenda</span><span class="p">),</span>
    <span class="nf">add_df</span><span class="p">(</span><span class="nv">Rest</span><span class="p">,</span><span class="nv">OldAgenda</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">NewAgenda</span><span class="p">).</span>
<span class="nf">add_df</span><span class="p">([</span><span class="nv">Child</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span><span class="nv">OldAgenda</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">NewAgenda</span><span class="p">):-</span>
    <span class="nf">element</span><span class="p">(</span><span class="nv">Child</span><span class="p">,</span><span class="nv">Visited</span><span class="p">),</span>
    <span class="nf">add_df</span><span class="p">(</span><span class="nv">Rest</span><span class="p">,</span><span class="nv">OldAgenda</span><span class="p">,</span><span class="nv">Visited</span><span class="p">,</span><span class="nv">NewAgenda</span><span class="p">).</span>
</pre></div>
</div>
<p>Note that the combination of loop detection and path construction allows the following optimisation: instead of maintaining complete paths to a node on the agenda and the list of visited nodes, we only store a node together with its parent. Once we encounter a goal, all its parents are on the list of visited nodes, which allows us to reconstruct the path.</p>
<div class="admonition exercise" id="ex-5-1">
<p class="admonition-title"><span class="caption-number">Exercise 5.1 </span><a class="headerlink" href="#ex-5-1" title="Permalink to this exercise">¶</a></p>
<p>Modify the predicate <code class="docutils literal notranslate"><span class="pre">search_df_loop/3</span></code> such that it reconstructs the path to a goal in this way.</p>
</div>
<p>We now analyse depth-first search with respect to completeness, optimality and efficiency. A search strategy is <em>complete</em> if it is guaranteed to find every goal. Obviously, any exhaustive strategy is complete for finite search spaces. However, in an infinite search space depth-first search might get trapped in an infinite branch before having found all the solutions. For instance, reconsider the infinite SLD-tree in <a class="reference internal" href="../1_part_i/3.1.html#fig-3-2"><span class="std std-numref">Figure 3.2</span></a>. A left-to-right depth-first search strategy would dive deeper and deeper into the tree, taking the left branch at every node, and never find the goals in the branches to the right. So, <em>depth-first search is, in general, incomplete</em>. Since Prolog itself employs depth-first search, Prolog is also incomplete. Often, however, the incompleteness of Prolog can be avoided by reordering the clauses such that goals are found before infinite branches (for instance, by putting the recursive clause last), and to cut away the infinite parts of the search space.</p>
<p>If there is no cost function, a search strategy is optimal if it is guaranteed to reach any goal along the shortest path possible. The Staatsgalerie example already showed that this is not true for depth-first search: you found your friend but, while she was in a room next to your initial position, you finally reached that room through two other rooms. Thus, <em>depth-first search does not always find a shortest solution path</em>. Finally, we can estimate the memory requirements for depth-first search as follows. Suppose we are searching a tree in which each node has, on the average, <span class="math notranslate nohighlight">\(B\)</span> children. The number <span class="math notranslate nohighlight">\(B\)</span> is known as the <em>branching factor</em>. Generating the children of a node adds <span class="math notranslate nohighlight">\(B\)</span> nodes to the agenda. We are interested in the following question: if a goal is found at depth <span class="math notranslate nohighlight">\(n\)</span> (i.e. the path from the root to the goal has length <span class="math notranslate nohighlight">\(n\)</span>), how many nodes are there on the agenda? Since at each level only the children of a single node are generated, the size of the agenda is of the order <span class="math notranslate nohighlight">\(B \times n\)</span>, that is, a linear function of the depth of the tree. The time complexity of depth-first search is of the order <span class="math notranslate nohighlight">\(B^n\)</span>, since the runtime is proportional to the number of nodes searched, and in the worst case the goal is found in the last branch, after searching <span class="math notranslate nohighlight">\(B^n\)</span> nodes. Of course, we cannot hope to achieve any better for blind exhaustive search!</p>
<p>In practice, depth-first search is only implemented as above if loop detection is an absolute must. Otherwise, the agenda is represented <em>implicitly</em> by means of Prolog’s internal goal stack. Children of a given node are generated one at a time, by means of Prolog’s backtracking mechanism, and examined immediately upon generation:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% depth-first search by means of backtracking</span>
<span class="nf">search_bt</span><span class="p">(</span><span class="nv">Goal</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">goal</span><span class="p">(</span><span class="nv">Goal</span><span class="p">).</span>
<span class="nf">search_bt</span><span class="p">(</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">arc</span><span class="p">(</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Child</span><span class="p">),</span>
    <span class="nf">search_bt</span><span class="p">(</span><span class="nv">Child</span><span class="p">,</span><span class="nv">Goal</span><span class="p">).</span>
</pre></div>
</div>
<p>If there is a chance that the search program gets trapped in an infinite loop, it might be a good idea to employ a predefined <em>depth bound</em>:</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% backtracking depth-first search with depth bound</span>
<span class="nf">search_d</span><span class="p">(</span><span class="nv">D</span><span class="p">,</span><span class="nv">Goal</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">goal</span><span class="p">(</span><span class="nv">Goal</span><span class="p">).</span>
<span class="nf">search_d</span><span class="p">(</span><span class="nv">D</span><span class="p">,</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nv">D</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="nv">D1</span> <span class="o">is</span> <span class="nv">D</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="nf">arc</span><span class="p">(</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Child</span><span class="p">),</span>
    <span class="nf">search_d</span><span class="p">(</span><span class="nv">D1</span><span class="p">,</span><span class="nv">Child</span><span class="p">,</span><span class="nv">Goal</span><span class="p">).</span>
</pre></div>
</div>
<p>In this way the search process is guaranteed to halt, but solutions which appear beyond the depth bound are missed.</p>
<p><em>Iterative deepening</em> is a form of depth-first search which employs a depth bound that is increased on each iteration. That is, after performing a depth-first search with depth bound <span class="math notranslate nohighlight">\(d\)</span>, search starts all over again from the starting nodes with an increased depth bound <span class="math notranslate nohighlight">\(d + n\)</span>. The predicate <code class="docutils literal notranslate"><span class="pre">search_id/2</span></code> implements iterative deepening for <span class="math notranslate nohighlight">\(n = 1\)</span>.</p>
<div class="highlight-Prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% iterative deepening</span>
<span class="nf">search_id</span><span class="p">(</span><span class="nv">First</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">search_id</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nv">First</span><span class="p">,</span><span class="nv">Goal</span><span class="p">).</span>     <span class="c1">% start with depth 1</span>

<span class="nf">search_id</span><span class="p">(</span><span class="nv">D</span><span class="p">,</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nf">search_d</span><span class="p">(</span><span class="nv">D</span><span class="p">,</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Goal</span><span class="p">).</span>
<span class="nf">search_id</span><span class="p">(</span><span class="nv">D</span><span class="p">,</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Goal</span><span class="p">):-</span>
    <span class="nv">D1</span> <span class="o">is</span> <span class="nv">D</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>                   <span class="c1">% increase depth</span>
    <span class="nf">search_id</span><span class="p">(</span><span class="nv">D1</span><span class="p">,</span><span class="nv">Current</span><span class="p">,</span><span class="nv">Goal</span><span class="p">).</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Here is iterative deepening applied to the palindrome example. Note no depth bound is needed.
Also note that the query just provides the starting node, not an initial agenda, due to the use of backtracking search within iterative deepening (<code class="docutils literal notranslate"><span class="pre">search_d/3</span></code>).</p>
<div class="extract swish highlight highlight-Prolog notranslate" id="swish-search-id">
<pre class="literal-block source swish" id="swish-search-id-code" source-text-start="search_id(First,Goal):-
    search_id(1,First,Goal).     % start with depth 1

search_id(D,Current,Goal):-
    search_d(D,Current,Goal).
search_id(D,Current,Goal):-
    D1 is D+1,                   % increase depth
    search_id(D1,Current,Goal).

% backtracking depth-first search with depth bound
search_d(_D,Goal,Goal):-
    goal(Goal).
search_d(D,Current,Goal):-
    D&gt;0, D1 is D-1,
    arc(Current,Child),
    search_d(D1,Child,Goal).

children(Node,Children):-
    findall(C,arc(Node,C),Children).

">
<span></span><span class="c1">% nodes are lists of letters</span>
<span class="nf">arc</span><span class="p">(</span><span class="nv">T</span><span class="p">,[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">]):-</span>
    <span class="c1">%length(T,N),N&lt;11,           % depth bound no longer needed</span>
    <span class="nf">member</span><span class="p">(</span><span class="nv">H</span><span class="p">,[</span><span class="s s-Atom">a</span><span class="p">,</span><span class="s s-Atom">d</span><span class="p">,</span><span class="s s-Atom">i</span><span class="p">,</span><span class="s s-Atom">m</span><span class="p">]).</span>

<span class="c1">% find palindromes</span>
<span class="nf">goal</span><span class="p">(</span><span class="nv">L</span><span class="p">):-</span>
    <span class="nf">reverse</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span><span class="nv">L</span><span class="p">).</span><div class="hide-examples">

<span class="cm">/** &lt;examples&gt;</span>
<span class="cm">?-search_id([a,d,a,m],Goal).</span>
<span class="cm">*/</span></div>
</pre></div>
</div>
<p>A big advantage of iterative deepening over simple depth-first search is that iterative deepening is complete: it will find all the goals at depth <span class="math notranslate nohighlight">\(d\)</span> and less before proceeding to depth <span class="math notranslate nohighlight">\(d + n\)</span>. Moreover, if we set the depth increment <span class="math notranslate nohighlight">\(n\)</span> to <span class="math notranslate nohighlight">\(1\)</span>, iterative deepening is also optimal: it will find shorter paths first. A disadvantage of iterative deepening is that upper parts of the search space are searched more than once (and goals in those upper parts are found more than once as well).</p>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./src/text/2_part_ii"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

    <script>$(function() { $(".swish").LPN({swish:"https://swish.simply-logical.space/"}); });</script>


              </div>
              
        
            <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="5.1.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">5.1. </span>A general search procedure</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="5.3.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">5.3. </span>Breadth-first search</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By <a href="mailto:Peter.Flach@bristol.ac.uk">Peter Flach</a> and <a href="mailto:K.Sokol@bristol.ac.uk">Kacper Sokol</a>, University of Bristol, United Kingdom
<br/>
        
            &copy; Copyright 2015–2021.<br/>
          <div class="extra_footer">
            <p> This work is licenced under the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licence</a>. </p> <p> This book discusses methods to implement intelligent reasoning by means of Prolog programs. The book is written from the shared viewpoints of Computational Logic, which aims at automating various kinds of reasoning, and Artificial Intelligence, which seeks to implement aspects of intelligent behaviour on a computer. </p>

          </div>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>